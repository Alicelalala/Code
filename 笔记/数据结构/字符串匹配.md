

### 字符串匹配

1、暴力匹配

 	方法一：每一次从模式串的第一位开始匹配，直到完全匹配，若不匹配，母串向后移动一位继续从模式串的第一位开始。

​	方法二：观察模式串,跳动匹配。

​	a	e	c	a	e	a	e	c	a	e	d

​	a	e	c	a	e	d

​	如此模式串，如果匹配到模式串第六位失配，可直接向后移动三位开始匹配，即判断a是否等于模式串的c.(移动位n-1) n：模式串失配的位置，模式串向前跳三位，说明前两位一定匹配，母串指针一定不会向前动。

### KMP 算法

​	母串	a	e	a	d	a	e	a	d	a	e	a	e	

​	-1	-1	0	-1	0	1	2	3	4	5	6	1

​	模式串	a	e	c	a	e	d

​	-1	-1	-1	0	1	-1

a与d不匹配，d的前一个节点的next是1,则将a与模式串[1+1]的位置相匹配，发现a与c也不匹配，c的前一个是e，e的next是-1，则将a与模式串[-1+1]的位置相匹配，发现a与a相匹配，现在可以开始继续向后匹配母串与模式串。

时间O(n*m)

### SUNDAY算法

//单词匹配

黄金对齐点

判断母串i+len位置的字符在模式串中最后一次出现的位置，将它两对齐，从头匹配

母串：	a	e	c	a	e	a	e	c	a	e	d

模式串     a	e	c	a	e	d

a与d不匹配，母串指针向后移动两位，使母串a与模式串最后一个a相匹配。

时间：最优时间复杂度 O(m/n)

### SHIFT-AND算法

//NFA

p = (p << 1 | 1) & d[s[i]]

前一个匹配成功前i位或者前j位，新进来的字符若能够匹配成功则说明当前字符出现在母串第i+1位或者j+1位，且它的前一个字符前i、j位一定匹配成。 | 1是因为，当前字符可能为第一个。

&前面是当前字符可能匹配的位置，&后是真实位置。

p & (1 << (n - 1)) ?=1 判断是否匹配成功。

整理模式串状态码。

O(n*m/K) 若m模式串小于32,则约为O(n)复杂度

